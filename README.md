# KAVN - Клеточный Автомат фон Неймана

Выполнил: Мироненко Павел Александрович  
Группа: 211-727

Проект выполнен для получения зачёта по дисциплине "Введение в программирование" на 1-м семестре в Московском Политехе.

## Содержание
1. [О проекте](#о-проекте)
2. [Состояния](#состояния)
3. [Правила перехода между состояниями](#правила-перехода-между-состояниями)
    - [Переходные состояния](#переходные-состояния)
    - [Конфлюентные состояния](#конфлюентные-состояния)
    - [Чувствительные состояния](#чувствительные-состояния)
    - [Правила разрушения](#правила-разрушения)
4. [Модификации клеточного автомата](#модификации-клеточного-автомата)
5. [Технические решения](#технические-решения)
6. [Структура программы](#структура-программы)
    - [Модуль логики](#модуль-логики)
    - [Модуль интерфейса](#модуль-интерфейса)
    - [Модуль отрисовки](#модуль-отрисовки)
7. [Полученный опыт](#полученный-опыт)
8. [Дальнейшие планы на этот проект](#дальнейшие-планы-на-этот-проект)

## О проекте
> [Клеточный автомат фон Неймана](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0) — клеточный автомат, разработанный Джоном фон Нейманом при содействии Станислава Улама для исследования возможности создания самовоспроизводящихся машин.

> Клеточный автомат в общем виде представляет собой упорядоченное множество конечных автоматов, обменивающихся информацией с соседними автоматами. В клеточном автомате фон Неймана ячейки упорядочены в виде двухмерной прямоугольной решетки и взаимодействуют с четырьмя непосредственно прилегающими ячейками, образующими [окрестность фон Неймана](https://ru.wikipedia.org/wiki/%D0%9E%D0%BA%D1%80%D0%B5%D1%81%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0). Решетка считается имеющей бесконечный размер в обоих направлениях, а ячейки — идентичными в плане правил перехода. Изменение состояний всех ячеек происходит синхронно.
&copy; Wikipedia

## Состояния
Всего в своём клеточном автомате фон Нейман выделял 3 категории ячеек и 29 состояний[&sup1;](#сноска-1):

1. Невозбудимые -- эта категория состоит всего из одного состояния, которое обозначается буквой **U** и является базовым состоянием для ячеек. Также называется состоянием полного покоя.

1. Возбудимые -- состояния, которые имеют дополнительные состояния, обозначающие их возбуждённость.
Фон Нейман выделял среди них 3 класса:

	- Конфлюентные (англ. _confluence_ — слияние) -- состояния, способные хранить 2 бита информации из-за задержки на 1 такт.
	Обозначается буквой **C** с двумя приписками, обозначающими полученненные в текущем и предыдущем такте возбуждения.
	Получается 4 состояния с обозначением вида **Cₙₘ**, где **n** -- возбуждение, пришедшее на текущем такте, а **m** -- на предыдущем.

	- Обычные передающие -- состояния, способные передавать возбуждение другим ячейкам.
	Фон Нейман обозначал их записью вида **T₀ₙₘ**, где **n** -- обозначает направление передачи (0 - вправо, 1 - вверх, 2- влево, 3 - вниз), а **m** -- возбуждена ли сейчас ячейка.
	Всего получается 8 состояний, обозначающих 4 направления.

	- Специальные передающие -- состояния, способные передавать возбуждение другим ячейкам. Их отличие от обычных передающих состояний можно будет увидеть при рассмотрении правил изменения состояний.
	Фон Нейман обозначал их записью вида **T₁ₙₘ**, с расшифровкой, как и у обычных передающих состояний.
	Всего получается 8 состояний, обозначающих 4 направления.

1. Чувствительные -- состояния, носящие переходный характер. При получении определённого "кода" состоящего из последовательных поступивших или не поступивших возбуждений такие ячейки преобразуются в какой-либо из типов ячеек.
Фон Нейман отвечал, что эти состояния меняются каждый такт независимо от влияния на них других ячеек. Иными словами, каждое из них длится только один такт.
Обозначаются буквой **S** (хотя в работе Дж. фон Неймана эти состояния не имеют короткого обозначения) и последующим кодом, который уже был получен ячейкой.

Всего получаем 1 базовое, 4 конфлюентных, по 8 обычных и специальных передающих, и 8 чувствительных состояний, всего 29.

<a name="сноска-1">1</a> - по материалам работы  Дж. фон Неймана "Теория самовоспроизводящихся авоматов".

## Правила перехода между состояниями

Дальше описаны все возможные правила для перехода из одного состояния в другое, взятые с [википедии](https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0#%D0%9F%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D1%85%D0%BE%D0%B4%D0%B0_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D1%85_%D1%81%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B9).

### Переходные состояния

Поток информации между ячейками определяется свойством направленности. Применяются следующие правила:

- Передающие состояния применяют оператор **ИЛИ** к входным сигналам, то есть ячейка в передающем состоянии (обычном или специальном) перейдет в возбужденное на такте **t+1** если любой из входных сигналов является возбужденным на такте **t**
- Состояния передаются между передающими ячейками соответственно свойству направленности.
- Обычные и специальные передающие состояния являются «антагонистами»:
	- Если ячейка **А** на такте **t** в обычном возбужденном передающем состоянии указывает на ячейку **В** в любом специальном передающем состоянии, то на такте **t+1** ячейка **В** перейдет в базовое состояние **U**. Особое передающее состояние будет "уничтожено".
	- Аналогичное событие произойдет, если ячейка в специальном передающем состоянии будет указывать на обычную передающую ячейку.

### Конфлюентные состояния

Следующие правила применяются к конфлюентным состояниям:

- Конфлюентные ячейки не передают данных между собой.
- Конфлюентные ячейки принимают входные сигналы от одной или нескольких обычных передающих ячеек и выдают их передающим ячейкам (обычным или специальным), которые не указывают на текущую ячейку.
- Данные не передаются в направлении, обратном направленности передающей ячейки.
- Данные, хранимые конфлюентной ячейкой, теряются, если у неё нет прилегающих передающих ячеек (не указывающих на неё).
- Конфлюентные ячейки служат мостами между обычными и специальными передающими ячейками.
- Конфлюентные ячейки применяют оператор **И** к входным сигналам.
- Конфлюентные ячейки задерживают сигнал на один такт дольше, чем обычные передающие ячейки.

### Чувствительные состояния

В исходном состоянии большая часть клеточного пространства является «пустой», то есть заполненной ячейками в состоянии **U.** Получив входной сигнал от передающей ячейки, соседняя ячейка в состоянии **U** переходит в чувствительное состояние, проходит ряд состояний и оказывается в одном из передающих или конфлюентных состояний. Это конечное состояние определяется последовательностью входных сигналов. То есть чувствительные состояния могут рассматриваться как точки бифуркации на пути от базового состояния к передающим и конфлюентным. В следующих правилах последовательность входных сигналов указана в скобках двоичной строкой:

- ячейка в базовом состоянии **U**, получив сигнал, переходит в состояние **S** *(1)*
	- ячейка в состоянии **S**, не получив сигнала, переходит в состояние **S₀** *(10)*
		- ячейка в состоянии **S₀**, не получив сигнала, переходит в **S₀₀** *(100)*
			- ячейка **S₀₀**, не получив сигнала, переходит в **S₀₀₀** *(1000)*
				- ячейка **S₀₀₀**, не получив сигнала, переходит в **T₀₀₀** *(10000)*
				- ячейка **S₀₀₀**, получив сигнал, переходит в **T₀₁₀** *(10001)*
			- ячейка **S₀₀**, получив сигнал, переходит в **T₀₂₀** *(1001)*
		- ячейка **S₀**, получив сигнал, переходит в **S₀₁** *(101)*
			- ячейка **S₀₁**, не получив сигнала, переходит в **T₀₃₀** *(1010)*
			- ячейка **S₀₁**, получив сигнал, переходит в **T₁₀₀** *(1011)*
	- ячейка **S**, получив сигнал, переходит в **S₁** *(11)*
		- ячейка **S₁**, не получив сигнала, переходит в **S₁₀** *(110)*
			- ячейка **S₁₀**, не получив сигнала, переходит в **T₁₁₀** *(1100)*
			- ячейка **S₁₀**, получив сигнал, переходит в **T₁₂₀** *(1101)*
		- ячейка **S₁**, получив сигнал, переходит в **S₁₁** *(111)*
			- ячейка **S₁₁**, не получив сигнала, переходит в **T₁₃₀** *(1110)*
			- ячейка **S₁₁**, получив сигнал, переходит в **C₀₀** *(1111)*

![Правила перехода чувствительных состояний](/img/sensitive_state_transition_rules.png)

### Правила разрушения

- Входной сигнал от специальной передающей ячейки, полученный ячейкой в конфлюентном или обычном передающем состоянии, переводит эту ячейку в базовое.
- Входной сигнал от обычной передающей ячейки, полученный специальной передающей ячейкой, переводит эту ячейку в базовое.

## Модификации клеточного автомата

> Одной из разновидностей автомата фон Неймана является автомат Нобили, в котором введены дополнительные состояния для обеспечения памяти и возможности пересечения сигналов без интерференции, для чего использована возможность хранения информации группами клеток. Последняя функция требует три дополнительных состояния, в силу чего автомат Нобили имеет 32 состояния, а не 29. Является изобретением Ренато Нобили (итал. Renato Nobili), профессора физики университета Падуя, Италия. Фон Нейман намеренно исключил состояния, предназначенные для пересечения сигналов.

> Конфлюентное состояние изменено таким образом, чтобы передавать независимо друг от друга два одновременно приходящих сигнала, либо запоминать и передавать с задержкой входные сигналы.

> Ещё одной разновидностью является автомат Хаттона (англ. Hutton), допускающий репликацию кольцевых структур (см. Langton's loops на английском языке).
&copy; Wikipedia

К сожалению, даже о клеточном автомате фон Неймана в русскоязычном сегменте интернета не очень легко найти информацию, а о его модификациях почти невозможно.
Поэтому я откладываю поиск более подробной информации до изучения мною английского языка на достаточном уровне.

## Технические решения

Используемые технологии:
- Язык программирования [Rust](https://www.rust-lang.org/).
- [Macroquad](https://macroquad.rs/) - библиотека, которую я использовал для отрисовки поля, создания окна, получения пользовательского ввода.
- [Egui](https://github.com/emilk/egui) и [egui-macroquad](https://github.com/optozorax/egui-macroquad) для создания графического интерфейса.
- [Native-dialog](https://crates.io/crates/native-dialog) для создания диалогов сохранения или выбора файла.
- [Serde](https://serde.rs/) для создания сохранений полей.

Язык программирования был выбран из-за личного интереса к нему, а библиотеки как наиболее легкие в использовании и освоении среди конкурентов (относительно моего уровня, конечно же).

## Структура программы

Программа разделена на модули, хотя их логика по итогу нарушилась.

Вот и они:
- [Модуль логики](#модуль-логики) - [cellular_automaton](./src/cellular_automaton).
- [Модуль интерфейса](#модуль-интерфейса) - [ui](./src/ui)
- [Модуль отрисовки](#модуль-отрисовки) - [draw](./src/draw)

Кроме них ещё планировался модуль для работы с файловой системой и сохранениями в частности, но из-за минималистичности использования Serde я решил, что не имеет смысла это выделять в отдельный модуль.

### Модуль логики

Состоит из 2-х частей:
- Описания состояний и переходов между ними ([тут](./src/cellular_automaton/states.rs))
- Описания поля и логики его обновления ([тут](./src/cellular_automaton/mod.rs))

Для достижения практически одновременного обновления ячеек (без влияния изменений друг на друга) я сначала собираю и запоминаю все нужные на данном такте изменения и лишь после применяю их.
Я избегаю некорректных изменений.
Для этого я не копирую размеры поля полностью, а сохраняю лишь значимые (ну или почти значимые) события в __HashMap__ с координатами ячеек.

Важный момент: у клеточного автомата внутри моделируется локальная система координат, а не используются индексы.
Это нужно для того, чтобы при расширении поля не сбивались всевозможные индексы.

Так как при работе с полем предполагаются бесконечные размеры оного, но практически такое сделать невозможно, я моделирую такое поведение с помощью простого расширения при достижении границ.

О решениях, которые понравились лично мне:
- Во время получения события я передаю соседей объединённых в итераторе с относительным положением проверяемой ячейки.
Это позволяет достаточно красивым сравнением проверять, направлен ли сосед на эту ячейки.
По сути ничего особенного и хорошего в этом нет, но мне понравилось.

Теперь о костылях и подобном:
- Поле расширяется не впритык к необходимому, а на + 2 строки/столбца.
Сделано так для того, чтобы можно было не обрабатывать возможность отсутствия соседей (+1) и избежания отсутствия обработки новых ячеек на границы (ещё +1). 
Второе вытекло из игнорирования первых и последних столбцов и строк при всевозможной обработке.
Этого можно было бы избежать при использовании __Option__, но к моменту появления этой идеи мне было уже лень исправлять.

### Модуль интерфейса

Самый неоднозначный модуль, потому что нарушает логику разделения (на мой взгляд).

Он управляет всеми остальными модулями и включает их в себя.

В целом в нём никаких интересных решений я не вижу, но зато вижу несколько некрасивых моментов:
- Достаточно криво сделано разделение.
- Обработка всевозможного ввода находится именно здесь, но из-за того, что я не хотел заморачиваться с отслеживанием нажатий на UI, а не на поле, я использую ПКМ (а не ЛКМ) для редактирования поля.
- Внутри находится обработка загрузки и выгрузки сохранений без какого-либо отделения.
Это легко исправить, но очень лень :)
- Практически имеет в себе довольно важные именно логические моменты (история, перемотки и т.п.).

### Модуль отрисовки

Здесь тоже не вижу никаких интересных для себя решений, но вполне нахожу те, которые стоит изменить (но делать я этого, конечно, не буду):
- Отсутствие использования констант. Из-за этого при малейшем изменении отрисовки придётся искать все места, где нужно изменения продублировать (а это не так уж и легко).
- Спорный момент: я каждый раз отрисовываю ячейки вручную, когда можно отрисовывать подготовленные картинки (например, svg).
Но так как мне лень с этим разбираться, я выбрал путь самурая.

## Полученный опыт

За время работы над этим проектом я:
- начал шире использовать распространённые инструменты (например, rust-fmt) и научился использовать некоторые новые библиотеки;
- сильнее разобрался с итераторами и конструкцией __match__ в расте. Было интересно;
- чуть лучше разобрался с __Markdown__ и __Git__ (но с последним недостаточно, к сожалению, я достаточно часто забывал о нём);
- сумел довести проект хотя бы до какого-то рабочего состояния, несмотря на то, что уже не хотел его продолжать (хотя бы что-то...);
- окончательно убедился, что выбирать проекты следует тщательнее, а переделывать их с нуля и доделывать ближе к концу сдачи не стоит.

## Дальнейшие планы на этот проект

Их нет. Я решил не продолжать его, потому что мне уже не интересно.

Пусть валяется на память.